package com.zim.paypal.service;

import com.zim.paypal.model.entity.TwoFactorAuth;
import com.zim.paypal.model.entity.User;
import com.zim.paypal.repository.TwoFactorAuthRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.security.SecureRandom;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;
import java.util.Optional;

/**
 * Service for Two-Factor Authentication
 * 
 * @author Zim Development Team
 */
@Service
@RequiredArgsConstructor
@Slf4j
@Transactional
public class TwoFactorService {

    private final TwoFactorAuthRepository twoFactorAuthRepository;
    private final SmsService smsService;
    private final EmailService emailService;
    private static final SecureRandom random = new SecureRandom();
    private static final int CODE_LENGTH = 6;
    private static final int CODE_VALIDITY_MINUTES = 10;

    /**
     * Generate 6-digit verification code
     * 
     * @return Verification code
     */
    public String generateVerificationCode() {
        int code = 100000 + random.nextInt(900000);
        return String.valueOf(code);
    }

    /**
     * Generate TOTP secret key
     * 
     * @return Base32 encoded secret
     */
    public String generateTotpSecret() {
        byte[] secretBytes = new byte[20];
        random.nextBytes(secretBytes);
        // In production, use Base32 encoding library
        return java.util.Base64.getEncoder().encodeToString(secretBytes);
    }

    /**
     * Generate backup codes
     * 
     * @param count Number of codes to generate
     * @return List of backup codes
     */
    public List<String> generateBackupCodes(int count) {
        List<String> codes = new ArrayList<>();
        for (int i = 0; i < count; i++) {
            int code = 10000000 + random.nextInt(90000000);
            codes.add(String.valueOf(code));
        }
        return codes;
    }

    /**
     * Get or create 2FA settings for user
     * 
     * @param user User entity
     * @return TwoFactorAuth entity
     */
    public TwoFactorAuth getOrCreateTwoFactorAuth(User user) {
        return twoFactorAuthRepository.findByUser(user)
                .orElseGet(() -> {
                    TwoFactorAuth twoFactorAuth = TwoFactorAuth.builder()
                            .user(user)
                            .isEnabled(false)
                            .method(TwoFactorAuth.AuthMethod.SMS)
                            .isVerified(false)
                            .build();
                    return twoFactorAuthRepository.save(twoFactorAuth);
                });
    }

    /**
     * Send verification code to user
     * 
     * @param user User entity
     * @param method Auth method
     * @return Verification code (for testing, in production don't return)
     */
    public String sendVerificationCode(User user, TwoFactorAuth.AuthMethod method) {
        TwoFactorAuth twoFactorAuth = getOrCreateTwoFactorAuth(user);
        
        if (twoFactorAuth.isLocked()) {
            throw new IllegalStateException("2FA is locked. Please try again later.");
        }

        String code = generateVerificationCode();
        
        // Store code temporarily (in production, use Redis or similar)
        // For now, we'll send it directly
        
        switch (method) {
            case SMS:
                if (twoFactorAuth.getPhoneNumber() == null || twoFactorAuth.getPhoneNumber().isEmpty()) {
                    throw new IllegalStateException("Phone number not set for SMS 2FA");
                }
                smsService.sendSms(twoFactorAuth.getPhoneNumber(), 
                        "Your Zim PayPal verification code is: " + code);
                break;
            case EMAIL:
                emailService.sendEmail(user.getEmail(), 
                        "Zim PayPal Verification Code",
                        "Your verification code is: " + code);
                break;
            case TOTP:
            case APP:
                // TOTP codes are generated by authenticator app
                break;
        }

        log.info("2FA code sent to user: {} via method: {}", user.getUsername(), method);
        return code; // In production, don't return the code
    }

    /**
     * Verify 2FA code
     * 
     * @param user User entity
     * @param code Verification code
     * @return true if valid
     */
    public boolean verifyCode(User user, String code) {
        TwoFactorAuth twoFactorAuth = getOrCreateTwoFactorAuth(user);
        
        if (twoFactorAuth.isLocked()) {
            throw new IllegalStateException("2FA is locked. Please try again later.");
        }

        // In production, verify against stored code in Redis/cache
        // For TOTP, verify using TOTP library
        // For now, this is a placeholder - actual implementation would verify against stored code
        
        boolean isValid = false;
        
        if (twoFactorAuth.getMethod() == TwoFactorAuth.AuthMethod.TOTP || 
            twoFactorAuth.getMethod() == TwoFactorAuth.AuthMethod.APP) {
            // Verify TOTP code using secret
            isValid = verifyTotpCode(twoFactorAuth.getSecret(), code);
        } else {
            // For SMS/EMAIL, verify against stored code (in production, use cache)
            // Placeholder - in real implementation, check against stored code
            isValid = code != null && code.length() == CODE_LENGTH;
        }

        if (isValid) {
            twoFactorAuth.resetFailedAttempts();
            twoFactorAuth.setLastUsedAt(LocalDateTime.now());
            twoFactorAuthRepository.save(twoFactorAuth);
            return true;
        } else {
            twoFactorAuth.incrementFailedAttempts();
            twoFactorAuthRepository.save(twoFactorAuth);
            return false;
        }
    }

    /**
     * Verify backup code
     * 
     * @param user User entity
     * @param backupCode Backup code
     * @return true if valid
     */
    public boolean verifyBackupCode(User user, String backupCode) {
        TwoFactorAuth twoFactorAuth = getOrCreateTwoFactorAuth(user);
        
        if (twoFactorAuth.getBackupCodes() == null || twoFactorAuth.getBackupCodes().isEmpty()) {
            return false;
        }

        // Parse backup codes (stored as JSON array)
        List<String> codes = parseBackupCodes(twoFactorAuth.getBackupCodes());
        
        if (codes.contains(backupCode)) {
            // Remove used backup code
            codes.remove(backupCode);
            twoFactorAuth.setBackupCodes(String.join(",", codes));
            twoFactorAuth.setLastUsedAt(LocalDateTime.now());
            twoFactorAuthRepository.save(twoFactorAuth);
            return true;
        }

        return false;
    }

    /**
     * Enable 2FA for user
     * 
     * @param user User entity
     * @param method Auth method
     * @param secret TOTP secret (for TOTP/APP methods)
     * @param phoneNumber Phone number (for SMS method)
     */
    public void enableTwoFactorAuth(User user, TwoFactorAuth.AuthMethod method, 
                                   String secret, String phoneNumber) {
        TwoFactorAuth twoFactorAuth = getOrCreateTwoFactorAuth(user);
        
        if (!twoFactorAuth.getIsVerified()) {
            throw new IllegalStateException("2FA must be verified before enabling");
        }

        twoFactorAuth.setIsEnabled(true);
        twoFactorAuth.setMethod(method);
        
        if (secret != null) {
            twoFactorAuth.setSecret(secret);
        }
        
        if (phoneNumber != null) {
            twoFactorAuth.setPhoneNumber(phoneNumber);
        }

        // Generate backup codes
        List<String> backupCodes = generateBackupCodes(10);
        twoFactorAuth.setBackupCodes(String.join(",", backupCodes));

        twoFactorAuthRepository.save(twoFactorAuth);
        log.info("2FA enabled for user: {} with method: {}", user.getUsername(), method);
    }

    /**
     * Disable 2FA for user
     * 
     * @param user User entity
     */
    public void disableTwoFactorAuth(User user) {
        TwoFactorAuth twoFactorAuth = getOrCreateTwoFactorAuth(user);
        twoFactorAuth.setIsEnabled(false);
        twoFactorAuth.setIsVerified(false);
        twoFactorAuth.setSecret(null);
        twoFactorAuth.setBackupCodes(null);
        twoFactorAuthRepository.save(twoFactorAuth);
        log.info("2FA disabled for user: {}", user.getUsername());
    }

    /**
     * Mark 2FA as verified (after initial setup)
     * 
     * @param user User entity
     */
    public void markAsVerified(User user) {
        TwoFactorAuth twoFactorAuth = getOrCreateTwoFactorAuth(user);
        twoFactorAuth.setIsVerified(true);
        twoFactorAuthRepository.save(twoFactorAuth);
    }

    /**
     * Check if user has 2FA enabled
     * 
     * @param user User entity
     * @return true if enabled
     */
    @Transactional(readOnly = true)
    public boolean isTwoFactorEnabled(User user) {
        return twoFactorAuthRepository.findByUser(user)
                .map(TwoFactorAuth::getIsEnabled)
                .orElse(false);
    }

    /**
     * Verify TOTP code (placeholder - use proper TOTP library in production)
     */
    private boolean verifyTotpCode(String secret, String code) {
        // In production, use a TOTP library like Google Authenticator library
        // This is a placeholder
        return code != null && code.length() == CODE_LENGTH;
    }

    /**
     * Parse backup codes from stored string
     */
    private List<String> parseBackupCodes(String backupCodesStr) {
        List<String> codes = new ArrayList<>();
        if (backupCodesStr != null && !backupCodesStr.isEmpty()) {
            String[] parts = backupCodesStr.split(",");
            for (String part : parts) {
                codes.add(part.trim());
            }
        }
        return codes;
    }
}

